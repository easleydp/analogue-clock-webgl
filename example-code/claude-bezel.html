<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clock Bezel - Three.js</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background: #1a1a1a;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 14px;
        z-index: 100;
      }
    </style>
  </head>
  <body>
    <div id="info">Clock Bezel - Rotate with mouse, zoom with scroll</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      const TAU = 2 * Math.PI;
      const PI = Math.PI;
      const HALF_PI = Math.PI / 2;

      function wrapAngle(angle) {
        return THREE.MathUtils.euclideanModulo(angle, TAU);
      }

      // Scene setup
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x222222);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      /**
       * Generates an array of THREE.Vector2 points forming a circular curve
       * between a start and end point.
       *
       * @param {THREE.Vector2} startPoint - The starting point of the curve.
       * @param {THREE.Vector2} endPoint - The ending point of the curve.
       * @param {number} sweep - The sweep angle of the curve in radians (<= Math.PI).
       * @param {number} intermediatePointCount - The number of intermediate points.
       * @returns {Array<THREE.Vector2>} An array of points, including start and end.
       */
      const generateCurvePoints = (
        startPoint,
        endPoint,
        sweep,
        intermediatePointCount
      ) => {
        const points = [];
        const chordLength = startPoint.distanceTo(endPoint);
        const nSegments = intermediatePointCount + 1;

        // Edge cases: straight line for zero distance or zero angle
        if (chordLength < 1e-6 || Math.abs(sweep) < 1e-6) {
          points.push(startPoint.clone());
          points.push(endPoint.clone());
          return points;
        }

        const radius = chordLength / (2 * Math.sin(sweep / 2));
        const h_center = Math.sqrt(
          Math.max(0, radius * radius - (chordLength / 2) * (chordLength / 2))
        );
        const midpoint = new THREE.Vector2()
          .addVectors(startPoint, endPoint)
          .multiplyScalar(0.5);
        const delta = new THREE.Vector2().subVectors(endPoint, startPoint);
        const perpDir = new THREE.Vector2(-delta.y, delta.x).normalize();

        const center = new THREE.Vector2().subVectors(
          midpoint,
          perpDir.clone().multiplyScalar(h_center)
        );

        const vec_C_to_S = new THREE.Vector2().subVectors(startPoint, center);
        const vec_C_to_E = new THREE.Vector2().subVectors(endPoint, center);

        // Determine the direction of rotation.
        let rotSign = Math.sign(vec_C_to_S.cross(vec_C_to_E));

        // Fallback for semi-circles (angle=PI) where vectors are collinear.
        if (rotSign === 0) {
          rotSign = -Math.sign(perpDir.cross(vec_C_to_S));
        }

        const angleIncrement = (rotSign * sweep) / nSegments;

        points.push(startPoint.clone());
        for (let i = 1; i <= intermediatePointCount; i++) {
          const currentAngle = i * angleIncrement;
          const pointOnCircle = vec_C_to_S
            .clone()
            .rotateAround(new THREE.Vector2(0, 0), currentAngle);
          points.push(pointOnCircle.add(center));
        }
        points.push(endPoint.clone());

        return points;
      };

      const generatePoints = ({
        radius,
        pinHoleRadius,
        pinRadius,
        pinH1,
        pinH2,
        bezelDiagH,
        bezelDiagW,
        bezelCurveW,
        curveSegments,
      }) => {
        if (radius === undefined) throw new Error("radius must be specified");
        pinRadius = pinRadius || radius / 50;
        pinHoleRadius = pinHoleRadius || pinRadius / 4;
        if (pinRadius >= radius)
          throw new Error("pinRadius must be less than radius");
        if (pinRadius <= pinHoleRadius)
          throw new Error("pinRadius must be greater than pinHoleRadius");
        bezelDiagW = bezelDiagW || radius / 40;
        bezelDiagH = bezelDiagH || bezelDiagW * 2;
        bezelCurveW = bezelCurveW || bezelDiagW * 2;
        pinH1 = pinH1 || bezelDiagH * 1.5;
        pinH2 = pinH2 || pinH1 + pinRadius / 3;
        if (pinH1 >= pinH2) throw new Error("pinH1 must be less than pinH2");
        curveSegments = curveSegments || 12;

        const points = [];

        // Pin start
        points.push(new THREE.Vector2(pinHoleRadius, pinH1));
        points.push(new THREE.Vector2(pinHoleRadius, pinH2));
        // Pin's outer edge is small curved bevel
        points.push(
          ...generateCurvePoints(
            new THREE.Vector2(pinRadius, pinH2),
            new THREE.Vector2(pinRadius + pinH2 - pinH1, pinH1),
            HALF_PI,
            4
          )
        );
        // Terminate the pin with a point with y=0
        points.push(new THREE.Vector2(pinRadius + pinH2 - pinH1, 0));

        // Bezel starts with a diagonal up from y=0 and terminates with a curve down to y=0
        points.push(new THREE.Vector2(radius - bezelDiagW - bezelCurveW, 0));
        points.push(
          ...generateCurvePoints(
            new THREE.Vector2(radius - bezelCurveW, bezelDiagH),
            new THREE.Vector2(radius, 0),
            PI,
            curveSegments
          )
        );

        return points;
      };

      // Create the LatheGeometry
      const points = generatePoints({ radius: 1 });
      const geometry = new THREE.LatheGeometry(points, 96);

      // Create gold material
      const material = new THREE.MeshStandardMaterial({
        color: 0xffd700,
        metalness: 0.8,
        roughness: 0.2,
        side: THREE.DoubleSide,
      });

      // Create the bezel mesh
      const bezel = new THREE.Mesh(geometry, material);

      // Scale up the bezel to a reasonable size
      bezel.scale.set(4, 4, 4);

      // Rotate so the clock face points toward the camera
      // The lathe creates geometry along the Y axis, so we need to rotate
      bezel.rotation.x = 0; // Keep it upright for clock orientation

      scene.add(bezel);

      // Lighting setup
      const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 5, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // Add a rim light for better gold appearance
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
      rimLight.position.set(-5, 2, -5);
      scene.add(rimLight);

      // Camera position
      camera.position.set(0, 0, 8);
      camera.lookAt(0, 0, 0);

      // Mouse controls
      let mouseX = 0;
      let mouseY = 0;
      let isMouseDown = false;
      let rotationX = 0;
      let rotationY = 0;

      document.addEventListener("mousedown", (e) => {
        isMouseDown = true;
        mouseX = e.clientX;
        mouseY = e.clientY;
      });

      document.addEventListener("mouseup", () => {
        isMouseDown = false;
      });

      document.addEventListener("mousemove", (e) => {
        if (isMouseDown) {
          const deltaX = e.clientX - mouseX;
          const deltaY = e.clientY - mouseY;

          rotationY += deltaX * 0.01;
          rotationX += deltaY * 0.01;

          // Clamp vertical rotation
          rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));

          mouseX = e.clientX;
          mouseY = e.clientY;
        }
      });

      // Zoom with mouse wheel
      document.addEventListener("wheel", (e) => {
        const zoomSpeed = 0.1;
        const zoom = e.deltaY > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
        camera.position.multiplyScalar(zoom);

        // Clamp zoom
        const distance = camera.position.length();
        if (distance < 2) {
          camera.position.normalize().multiplyScalar(2);
        } else if (distance > 20) {
          camera.position.normalize().multiplyScalar(20);
        }
      });

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        // Apply rotations
        bezel.rotation.y = rotationY;
        bezel.rotation.x = rotationX;

        renderer.render(scene, camera);
      }

      // Handle window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Start animation
      animate();
    </script>
  </body>
</html>
